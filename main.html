<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ClickGame</title>

    <style>
        body {
            margin: 0; /* 要素の外側の余白 */
            overflow: hidden; /* はみ出した要素を隠す、スクロールを無効化 */
            user-select: none;
            -webkit-user-select: none;
        }

        img {
            -webkit-user-drag: none;
        }

        /* 上：ゲーム画面（60%） */
        #gameContainer {
            height: 60vh;
            position: relative;
            background: #eef;
            overflow: hidden;
        }

        #btn {
            position: absolute;
            width: 100px;
            height: 100px;
            cursor: pointer;
        }

        .flyClone{
            position: absolute;
            width: 100px;
            height: 100px;
        }

        .cat-paw {
            position: absolute;
            width: 160px; /* 叩くときに75%(120px) */
            height: auto; /* 1280px */
            z-index: 5; /* 重なり順(UIの後ろ) */
            pointer-events: none; /* クリックを邪魔しない */
            transform: translate(-50%, -50%); /* 指定座標に中心寄せ */
            opacity: 0; /* 透明度(0 or 1) */
            transition: 
                opacity 0.1s ease-in, /* 透明度変更を 0.1 秒, 遅→速 */
                transform 0.1s ease-in;
        }

        .comboText {
            position: absolute;
            font-size: 25px;
            z-index: 6;
            pointer-events: none;
            transform: translate(-50%, -50%); /* 指定座標に中心寄せ */
            opacity: 0;
            transition: 
                opacity 0.4s ease, /* 透明度変更を 0.4 秒, ふわっと */
                transform 0.4s ease;
        }

        #statusBox {
            position: absolute;
            right: 10px; /* 親要素の右端から */
            bottom: 10px; /* 親要素の下端から */
            background: rgba(255,255,255,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            text-align: right;
            align-items: center;
            z-index: 10; /* 重なり順(最前面) */
            pointer-events: none; /* ←クリックを邪魔しない */
            font-size: 18px;
        }

        #comboGauge {
            width: 60px;
            height: 60px;
        }

        /* 下：flappy（40%） */
        #flappyContainer {
            position: relative;
            height: 40vh;
            width: 100vw;
            overflow: hidden;
            background: #fafafa;
        }
        #flappyBgSpace {
            position: absolute;
            inset: 0; /* 親要素いっぱい */
            background:hsl(240, 100%, 20%);
            z-index: 0;
        }
        #flappyBgSky {
            position: absolute;
            inset: 0; /* 親要素いっぱい */
            background: linear-gradient(
                to bottom, /* 上から下へのグラデーション */
                #1b1b2f 0%,
                #4b6cb7 40%,
                #87ceeb 70%,
                #cce6ff 100%
            );
            z-index: 1;
        }
        #flappyChar {
            position: absolute;
            height: 120px;
            width: 80px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        #flappyGround {
            position: absolute;
            top: 50%;       /* 地面の高さ */
            left: 0;
            width: 100%;
            height: 2px;        /* 線なので細く */
            background: #333;
            z-index: 5;
        }
        #flappyWind {
            position: absolute;
            inset: 0; /* 親要素いっぱい */
            pointer-events: none;
            z-index: 9; /* キャラの少し後ろ */
        }
        .windLine {
            position: absolute;
            width: 60px;
            height: 2px;
            background: rgba(255,255,255,0.6);
            border-radius: 2px;
        }
    </style>
</head>

<body>

    <!-- 上：ゲーム部分 -->
    <div id="gameContainer">
        <img id="btn" src="realisticFly.png">
        <div id="statusBox">
            <canvas id="comboGauge" width="60" height="60"></canvas>
            <div id="scoreDisplay">Score: 0</div>
            <div id="comboDisplay">Combo: 0</div>
        </div>
    </div>

    <!-- 下：フラッピーゾーン -->
    <div id="flappyContainer">
        <div id="flappyBgSpace"></div>
        <div id="flappyBgSky"></div>
        <img id="flappyChar" src="rocket-red.png">
        <div id="flappyGround"></div>
        <div id="flappyWind"></div>
    </div>

<script>

const btn = document.getElementById("btn");
btn.addEventListener("click", clicked);
const gameContainer = document.getElementById("gameContainer");
const gaugeCanvas = document.getElementById("comboGauge");
const gctx = gaugeCanvas.getContext("2d");
const flappyContainer = document.getElementById("flappyContainer")
const flappyBgSky = document.getElementById("flappyBgSky");
const flappyChar = document.getElementById("flappyChar");
const flappyGround = document.getElementById("flappyGround")
const flappyWind = document.getElementById("flappyWind");

let gravity = 9.8;
const frameRate = 60 // 毎秒
let lastTime = Date.now(); // フレーム間の正確な時間測定用

let score = 0;
let scoreVel = 0; // score increase per second
let flappyVelX = 0;
const FLAPPY_PX_PER_UNIT = 80; // フラッピーゾーン独自の長さをpxに変換
let lastClickTime = 0;
let combo = 0;
let comboLimit = 3000; // ミリ秒
let flappyAngle = 0;
const altitudeAndColor = [
    [0, [200, 80, 85, 100]], // h,s,l,a
    [75, [205, 70, 75, 100]],
    [150, [215, 60, 65, 100]],
    [250, [230, 55, 50, 100]],
    [325, [245, 65, 40, 100]],
    [400, [255, 80, 30, 100]],
    [500, [240, 100, 20, 1]]
]
let flappyCameraZoom = 1; // 2 → 2倍ズームイン

// ズームアニメーション
let zoomFrom = 1; // 倍率
let zoomTo = 1; // 倍率
let zoomTimer = 0; // 経過時間
let zoomDuration = 0; // 所要時間sec
let zoomHoldingTimer = 0; // 
let zoomHoldingDuration = 0; // ズーム完了から戻り始めるまでの時間sec

const windList = [];

function spawnWind(scoreVel,deltaTime) {
    if (scoreVel === 0) return;

    const power = Math.abs(scoreVel);

    const spawnRate = Math.min(12*power, 600) / (flappyCameraZoom**2); // 1秒あたりの本数
    const count = Math.floor(spawnRate*deltaTime); // 1フレームあたりの本数
    for (let i = 0; i < count; i++) {
        const line = document.createElement("div");
        line.className = "windLine";

        const W = flappyContainer.clientWidth;
        const H = flappyContainer.clientHeight;
        const maxRange = Math.sqrt(W*W + H*H) / flappyCameraZoom; // エリアの対角線の長さ
        const extraX = (maxRange - W) / 2;
        const extraY = (maxRange - H) / 2;
        const x = Math.random() * maxRange - extraX;
        const y = Math.random() * maxRange - extraY;
        const duration = 0.5;

        line.style.left = x + "px";
        line.style.top = y + "px";
        line.style.width = `${power * 10}px`;

        flappyWind.appendChild(line);
        windList.push({el:line, ox:0, t:0, d:duration}) // element, offsetX(移動量), timer(sec), duration(sec)
    }
}

function updateWind(scoreVel, deltaTime) {
    for (let i = windList.length - 1; i >= 0; i--) {
        const w = windList[i];

        w.ox -= Math.abs(scoreVel * deltaTime * FLAPPY_PX_PER_UNIT) / flappyCameraZoom;
        w.t += deltaTime;

        w.el.style.transform = `translateX(${w.ox}px)`;
        w.el.style.width = `${Math.abs(scoreVel) * 10}px`;
        w.el.style.opacity = Math.max(0, 
            1 - Math.abs(w.t - w.d/2) / (w.d/2)
        ); // 透明度が、0 → 1 → 0

        if (w.t >= w.d) {
            w.el.remove();
            windList.splice(i, 1);
        }
    }
    flappyWind.style.transform = `scale(${flappyCameraZoom}, ${flappyCameraZoom}) rotate(${-flappyAngle}rad)`;
}

function updateStatus() {
    document.getElementById("scoreDisplay").textContent = "Score: " + Math.floor(score);
    document.getElementById("comboDisplay").textContent = "Combo: " + combo;
}

// ボタンをランダム位置へ動かす関数
function setRandomPosition() {
    const box = document.getElementById("statusBox");
    const boxW = box.offsetWidth;
    const boxH = box.offsetHeight;

    const maxX = gameContainer.clientWidth - btn.offsetWidth - boxW - 10;
    const maxY = gameContainer.clientHeight - btn.offsetHeight - boxH - 10;

    const x = Math.random() * maxX; /* ボタン左端座標 */
    const y = Math.random() * maxY; /* ボタン上端座標 */

    btn.style.left = x + "px"; /* インラインCSSでスタイル「left: 〇〇px;」を指定 */
    btn.style.top = y + "px";
}

function showComboText(x, y, combo) {
    const comboText = document.createElement("div")
    comboText.textContent = `${combo+1}コンボ！` // comboが増える前の処理なので+1
    comboText.className = "comboText"

    comboText.style.left = x + "px";
    comboText.style.top = y + "px";
    comboText.style.transform = `translate(-50%, -50%)`;
    gameContainer.appendChild(comboText);

    requestAnimationFrame(() => {
        comboText.style.opacity = 1;
        comboText.style.transform = `translate(-50%, -50%) scale(0.8)`;
    });

    setTimeout(() => {
        comboText.style.opacity = 0;
        comboText.style.transform = `translate(-50%, -50%) scale(1.5)`;
    }, 600);

    setTimeout(() => comboText.remove(), 1000);
}

function showCatPaw(x, y) {
    const flyClone = document.createElement("img")
    flyClone.src = "realisticFly.png";
    flyClone.className = "flyClone";
    const paw = document.createElement("img");
    paw.src = "catHand.png";
    paw.className = "cat-paw";

    const distance = 200;

    // 0 ~ 2π rad
    const angle = Math.random() * Math.PI * 2; /* 右が 0 rad */

    // 距離1を2軸に分解し、距離をかける
    const dx = Math.cos(angle) * distance;
    const dy = Math.sin(angle) * distance;

    paw.style.left = x + "px";
    paw.style.top = y + "px";
    paw.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) rotate(${angle - Math.PI/2}rad)`;
    flyClone.style.left = x + "px";
    flyClone.style.top = y + "px";
    flyClone.style.transform = `translate(-50%, -50%)`;

    gameContainer.appendChild(flyClone);
    gameContainer.appendChild(paw);

    requestAnimationFrame(() => {
        paw.style.opacity = 1;
        paw.style.transform = `translate(-50%, -50%) scale(0.75, 0.75) rotate(${angle - Math.PI/2}rad)`;
    });
    setTimeout(() => {
        paw.style.opacity = 1;
        paw.style.transform = `translate(calc(-50% + ${dx/distance*10}px), calc(-50% + ${dy/distance*10}px)) scale(0.75, 0.75) rotate(${angle - Math.PI/2}rad)`;
    }, 100);

    // 少し待ってフェードアウト
    setTimeout(() => {
        paw.style.opacity = 0;
        paw.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) rotate(${angle - Math.PI/2}rad)`;
    }, 400);

    // 完全に消す
    setTimeout(() => flyClone.remove(), 100)
    setTimeout(() => paw.remove(), 800);
}

function startZoom(from, to, duration) {
    zoomFrom = from;
    zoomTo = to;
    zoomTimer = 0;
    zoomDuration = duration;
}
function updateZoom(deltaTime) {
    if (zoomTimer < zoomDuration) {
        zoomTimer += deltaTime;
        const t = Math.min(zoomTimer / zoomDuration, 1);

        // easeOut（最初速い→最後遅い）
        const eased = 1 - Math.pow(1 - t, 3);

        flappyCameraZoom =
            zoomFrom * (1 - eased) +
            zoomTo * eased;
    } else if (zoomHoldingTimer < zoomHoldingDuration) {
        zoomHoldingTimer += deltaTime;
        if (zoomHoldingTimer >= zoomHoldingDuration) {
            zoomHoldingTimer = zoomHoldingDuration;
            startZoom(flappyCameraZoom, 1.0, 1.0);
        }
    }
}

// クリックされたらスコアアップ＋移動
function clicked() {
    const now = Date.now();
    showComboText(
        btn.offsetLeft + btn.offsetWidth / 2,
        btn.offsetTop + btn.offsetHeight / 2,
        combo
    )
    showCatPaw(
        btn.offsetLeft + btn.offsetWidth / 2,
        btn.offsetTop + btn.offsetHeight / 2
    );

    if (now - lastClickTime <= comboLimit || combo == 0) {
        combo++;
    }
    // scoreVel に combo を足す (9.8以上98以下)
    scoreVel = Math.max(
        gravity,
        Math.min(
            scoreVel + Math.floor(Math.pow(combo, 1/10)*9.8),
            gravity*10
        )
    )

    lastClickTime = now;
    updateStatus();
    setRandomPosition();

    // 0.15秒でズームアウト
    startZoom(flappyCameraZoom, 0.75, 0.15);

    zoomHoldingTimer = 0;
    zoomHoldingDuration = 0.15 + 0.3*(gravity + Math.floor(combo/5))/gravity;
    // ズームを元に戻す処理は updateZoom()
}

setRandomPosition(); // 最初の位置

function drawComboGauge() {
    const now = Date.now();
    const elapsed = now - lastClickTime;

    // 残り割合（1.0 → 0.0）
    let ratio = 1 - elapsed / comboLimit;
    if (ratio < 0) ratio = 0;

    const center = 30; // canvas 60 の半分
    const radius = 24; // 外側 - 太さ/2 (= 内側の半径)

    gctx.clearRect(0, 0, 60, 60); // x, y, width, height

    // 背景円
    gctx.beginPath();
    gctx.arc(center, center, radius, 0, Math.PI * 2); // x, y, radius, startAngle, endAngle
    gctx.strokeStyle = "#ddd";
    gctx.lineWidth = 10;
    gctx.stroke();

    // コンボ残りゲージ
    gctx.beginPath();
    gctx.arc(
        center,
        center,
        radius,
        -Math.PI / 2,
        -Math.PI / 2 + Math.PI * 2 * ratio
    );
    gctx.strokeStyle = "#ff9800";
    gctx.lineWidth = 6;
    gctx.stroke();
}

function updateFlappyChar(scoreVel, deltaTime) {
    flappyVelX = 10
    flappyAngle = Math.atan2(scoreVel, flappyVelX)

    flappyChar.style.transform =
        `translate(-50%, -50%) scale(${flappyCameraZoom}, ${flappyCameraZoom}) rotate(${-flappyAngle + Math.PI/2}rad)`;
}

function updateBackground(score) {
    const camHeight = flappyContainer.getBoundingClientRect().height / FLAPPY_PX_PER_UNIT * (1 / flappyCameraZoom);
    const camMin = score - camHeight / 2;

    const stops = altitudeAndColor.map(([alt, [h, s, l, a]]) => {
        const pos = (alt - camMin) / camHeight * 100;
        return `hsla(${h}, ${s}%, ${l}%, ${a}) ${pos}%`;
    });

    flappyBgSky.style.background =
        `linear-gradient(to top, ${stops.join(",")})`;
}


function drawFlappyGround(score) {
    flappyGround.style.transform = 
        `translate(0, calc(${flappyChar.getBoundingClientRect().height / 2 + score * FLAPPY_PX_PER_UNIT * (1 / flappyCameraZoom)}px))`;
}

setInterval(() => {
    const now = Date.now();
    const deltaTime = (now - lastTime) / 1000; // 秒
    lastTime = now;
    if (now - lastClickTime > comboLimit) {
        combo = 0;
    }

    // 減衰量の計算
    scoreVel -= gravity * deltaTime;
    score += scoreVel * deltaTime;

    if (score <= 0) {
        score = 0;
        scoreVel = 0;
    }

    updateStatus();
    drawComboGauge();

    updateZoom(deltaTime);
    updateFlappyChar(scoreVel, deltaTime);
    updateBackground(score);
    drawFlappyGround(score);
    spawnWind(scoreVel, deltaTime);
    updateWind(scoreVel, deltaTime);
}, 1000/frameRate);

</script>
</body>
</html>
